#! /usr/bin/env python3
"""
    Vulkan D bindings generator.
    Reads Vulkan XML API definition to produce the D bindings code.
    Also depends on the python scripts of Vulkan-Docs.
"""

from reg import Registry
from generator import OutputGenerator, GeneratorOptions, noneStr
import xml.etree.ElementTree as etree
from itertools import islice
import re

# General utility

class SourceFile(object):
    '''
    buffer to append code in various sections of a file
    in any order
    '''

    _one_indent_level = '    '

    def __init__(self, outFile):
        self._section = 0
        self._lines = []
        self._indents = []
        self._outFile = outFile

    def getsection(self):
        return self._section

    def section(self, section):
        '''
        Set the section of the file where to append code.
        Allows to make different sections in the file to append
        to in any order
        '''
        while len(self._lines) <= section:
            self._lines.append([])
        while len(self._indents) <= section:
            self._indents.append(0)
        self._section = section

    def getindent(self):
        '''
        returns indentation of the current section
        '''
        return self._indents[self._section]

    def setindent(self, indent):
        '''
        sets indentation of the current section
        '''
        self._indents[self._section] = indent;

    def indent_block(self):
        class Indenter(object):
            def __init__(self, sf):
                self.sf = sf
            def __enter__(self):
                self.sf.indent()
            def __exit__(self, type, value, traceback):
                self.sf.unindent()
        return Indenter(self)

    def indent(self):
        '''
        adds one level of indentation to the current section
        '''
        self._indents[self._section] += 1

    def unindent(self):
        '''
        removes one level of indentation to the current section
        '''
        assert self.getindent() > 0, "negative indent"
        self._indents[self._section] -= 1

    def __call__(self, fmt="", *args):
        '''
        Append a line to the file at in its current section and
        indentation of the current section
        '''
        indent = SourceFile._one_indent_level * self._indents[self._section]
        self._lines[self._section].append(indent + (fmt % args))


    def writeOut(self):
        for section in self._lines:
            for line in section:
                print(line.rstrip(), file=self._outFile)


# D specific utilities

re_single_const = re.compile(r"^const\s+(.+)\*\s*$")
re_double_const = re.compile(r"^const\s+(.+)\*\s+const\*\s*$")
re_funcptr = re.compile(r"^typedef (.+) \(VKAPI_PTR \*$")

dkeywords = [ "module" ]

def convertDTypeConst( typ ):
    """
    Converts C const syntax to D const syntax
    """
    doubleConstMatch = re.match( re_double_const, typ )
    if doubleConstMatch:
        return "const({}*)*".format( doubleConstMatch.group( 1 ))
    else:
        singleConstMatch = re.match( re_single_const, typ )
        if singleConstMatch:
            return "const({})*".format( singleConstMatch.group( 1 ))
    return typ

def makeDParamType(param):
    def makePart(part):
        return noneStr(part).strip().replace("const", "const ")

    typeStr = makePart(param.text)
    for elem in param:
        if elem.tag != "name":
            typeStr += makePart(elem.text)
        typeStr += makePart(elem.tail)

    return convertDTypeConst(typeStr.replace("const *", "const*"))

def mapDName(name):
    if name in dkeywords:
        return name + "_"
    return name

BASETYPE_SECT   = 1
CONST_SECT      = 2
FUNCPTR_SECT    = 3
ENUM_SECT       = 4
STRUCT_SECT     = 5

class DGenerator(OutputGenerator):

    def __init__(self, moduleName, outFile):
        super().__init__()
        self.moduleName = moduleName
        self.outFile = outFile
        self.basicTypes = {
            "uint8_t": "ubyte",
            "uint16_t": "ushort",
            "uint32_t": "uint",
            "uint64_t": "ulong",
            "int8_t": "byte",
            "int16_t": "short",
            "int32_t": "int",
            "int64_t": "long",
        }

    def logMsg(self, level, *args):
        # shut down logging during dev to see debug output
        # super().logMsg(level, *args)
        pass

    def beginFile(self, opts):
        # generator base class open and close a file
        # don't want that here as we may output to stdout
        # not calling super on purpose
        self.sf = SourceFile(self.outFile)
        self.sf.section(0)
        self.sf("/// Vulkan D bindings generated by vkdgen.py for Gfx-d")
        self.sf("module %s;", self.moduleName)

        self.sf.section(BASETYPE_SECT)
        self.sf()
        self.sf("// Basic types definition")
        self.sf()
        for k in self.basicTypes:
            self.sf("alias %s = %s;", k, self.basicTypes[k])

        self.sf.section(CONST_SECT)
        self.sf()
        self.sf("// Constants")
        self.sf()

        self.sf.section(ENUM_SECT)
        self.sf()
        self.sf("// Enumerations")
        self.sf()

        self.sf.section(STRUCT_SECT)
        self.sf()
        self.sf("// Structures")
        self.sf()

        self.sf.section(FUNCPTR_SECT)
        self.sf()
        self.sf("// Function pointers")
        self.sf()
        self.sf("extern(C) {")
        self.sf.indent()


    def endFile(self):
        # not calling super on purpose (see beginFile comment)
        self.sf.section(FUNCPTR_SECT)
        self.sf.unindent()
        self.sf("}")
        self.sf.writeOut()

    def beginFeature(self, interface, emit):
        super().beginFeature(interface, emit)
        # print("beginFeature", interface.get("name"))
        pass

    def endFeature(self):
        super().endFeature()
        pass

    def genType(self, typeinfo, name):
        super().genType(typeinfo, name)
        if "category" not in typeinfo.elem.attrib:
            return
        category = typeinfo.elem.attrib["category"]

        if category == "basetype" or category == "bitmask":
            self.sf.section(BASETYPE_SECT)
            self.sf("alias %s = %s;", name, typeinfo.elem.find("type").text)
        elif category == "struct" or category == "union":
            self.genStruct(typeinfo, name)
        elif category == "funcpointer":
            returnType = re.match( re_funcptr, typeinfo.elem.text ).group( 1 )
            params = "".join( islice( typeinfo.elem.itertext(), 2, None ))[ 2: ]
            if params == "void);" or params == " void );" : params = ");"
            #else: params = ' '.join( ' '.join( line.strip() for line in params.splitlines()).split())
            else:
                concatParams = ""
                for line in params.splitlines():
                    lineSplit = line.split()
                    if len( lineSplit ) > 2:
                        concatParams += ' ' + convertTypeConst( lineSplit[ 0 ] + ' ' + lineSplit[ 1 ] ) + ' ' + lineSplit[ 2 ]
                    else:
                        concatParams += ' ' + ' '.join( param for param in lineSplit )

                params = concatParams[ 2: ]

            self.sf.section(FUNCPTR_SECT)
            self.sf("alias %s = %s function(%s", name, returnType, params)


    def genEnum(self, enuminfo, name):
        super().genEnum(enuminfo, name)
        (_, strVal) = self.enumToValue(enuminfo.elem, False)
        self.sf.section(CONST_SECT)
        self.sf("enum %s = %s;", name,
                strVal.replace("0ULL", "0uL").replace("0U", "0u"))

    def genGroup(self, groupinfo, name):
        super().genGroup(groupinfo, name)
        repStr = ""
        if name.endswith("FlagBits"):
            # TODO: replace FlagBits by Flags
            repStr = ": VkFlags"

        self.sf.section(ENUM_SECT)
        self.sf("enum %s%s {", name, repStr)
        with self.sf.indent_block():
            for elem in groupinfo.elem.findall("enum"):
                (numVal, strVal) = self.enumToValue(elem, True)
                name = elem.get("name")
                self.sf("%s = %s,", name, numVal)
        self.sf("}")

    def genStruct(self, typeinfo, name):
        super().genStruct(typeinfo, name)
        category = typeinfo.elem.attrib["category"]
        maxLen = 0
        members = []
        for member in typeinfo.elem.findall(".//member"):
            typeStr = makeDParamType(member)
            maxLen = max(maxLen, len(typeStr))
            memName = member.findall(".//name")[0].text
            members.append([typeStr, mapDName(memName)])
        self.sf.section(STRUCT_SECT)
        self.sf("%s %s {", category, name)
        with self.sf.indent_block():
            for member in members:
                spacer = " " * (maxLen - len(member[0]) + 1)
                self.sf("%s%s%s;", member[0], spacer, member[1])
        self.sf("}")


# main driver starts here

if __name__ == "__main__":

    import sys
    import os
    from os import path
    import argparse

    vkdgenDir = os.path.dirname(os.path.realpath(__file__))
    vkXml = path.join(vkdgenDir, "vk.xml")

    parser = argparse.ArgumentParser(description="Generate Vulkan D bindings")

    parser.add_argument("-m, --module", dest="module", metavar="MODULE",
                help="D module name")
    parser.add_argument("-r, --registry", dest="registry", metavar="REGISTRY",
                help="Path to the XML registry [{}]".format(vkXml), default=vkXml)
    parser.add_argument("-o, --output", dest="output", metavar="OUTPUT",
                help="D output file to generate [stdout].", default="[stdout]")

    args = parser.parse_args(sys.argv[1:])

    outFile = sys.stdout if args.output == "[stdout]" else open(args.output, "w")

    gen = DGenerator(args.module, outFile)
    reg = Registry()
    reg.loadElementTree( etree.parse( args.registry ))
    reg.setGenerator( gen )
    reg.apiGen( GeneratorOptions(
        apiname = "vulkan",
        # addExtensions = ".*",
    ))

    if args.output != "[stdout]":
        outFile.close()
